#require (OS == "windows")

module runtime;

import sys.windows;

func sys_init() {
    _sys_stderr = windows.GetStdHandle(-12 as windows.DWORD);

    _tls_rstate_index = windows.TlsAlloc();
    if _tls_rstate_index == windows.TLS_OUT_OF_INDEXES {
        throw("bad tls alloc");
    }

    windows.AddVectoredExceptionHandler(0, _win_veh_handler._addr);
}

func sys_exit(exit_code: int) {
    windows.ExitProcess(exit_code as windows.UINT);
}

/* -------------------------------------------------------------------------- */

let _sys_stderr: windows.HANDLE;

func sys_eprint(b: []u8) {
    windows.WriteConsoleA(_sys_stderr, b._ptr, b._len as windows.DWORD, null, null);
}

/* -------------------------------------------------------------------------- */

enum _WinExcCode {
    AccessViolation = windows.EXCEPTION_ACCESS_VIOLATION;
    IntDivideByZero = windows.EXCEPTION_INT_DIVIDE_BY_ZERO;
    StackOverflow = windows.EXCEPTION_STACK_OVERFLOW;
    IntOverflow = windows.EXCEPTION_INT_OVERFLOW;
    FltDenormalOperand = windows.EXCEPTION_FLT_DENORMAL_OPERAND;
    FltDivideByZero = windows.EXCEPTION_FLT_DIVIDE_BY_ZERO;
    FltInexactResult = windows.EXCEPTION_FLT_INEXACT_RESULT;
    FltOverflow = windows.EXCEPTION_FLT_OVERFLOW;
    FltUnderflow = windows.EXCEPTION_FLT_UNDERFLOW;
}

func _win_veh_handler(exc_info: *windows.EXCEPTION_POINTERS) windows.DWORD {
    let code: _WinExcCode;
    unsafe {
        code = exc_info.ExceptionRecord.ExceptionCode as _WinExcCode;
    }

    match code {
    case .AccessViolation:
        _panic_mem(exc_info.ExceptionRecord._info2 as uint);
    case .IntDivideByZero:
        _panic_divide();
    case .StackOverflow:
        _panic_stack();
    case .IntOverflow:
        _panic_overflow();
    case .FltDenormalOperand | .FltDivideByZero | .FltInexactResult | .FltOverflow | .FltUnderflow:
        _panic_float();
    case _:
        return windows.EXCEPTION_CONTINUE_SEARCH;
    }

    // TODO: should we ever able to continue execution?  If so, we need to
    // increment rip appropriately which will require us to explicitly provide
    // an implementation for CONTEXT in sys.windows.  That could be dangerous
    // business indeed.
    // if (exc_info.ExceptionRecord.ExceptionFlags & windows.EXCEPTION_NONCONTINUABLE) > 0 {
    //     // TODO: fix for multithreading
    //     exit(1);
    // }

    // return windows.EXCEPTION_CONTINUE_EXECUTION;

    // All panic handlers should kill their current thread and thus never
    // return. If we reach here, something is very wrong with the runtime, and
    // we should abort immediately.
    throw("panic handler returned");

    // Unreachable.
    return windows.EXCEPTION_CONTINUE_SEARCH;
}

/* -------------------------------------------------------------------------- */

let _tls_rstate_index: windows.DWORD = windows.TLS_OUT_OF_INDEXES;

func get_rstate() *Rstate {
    let rstate: *Rstate;

    unsafe {
        rstate = windows.TlsGetValue(_tls_rstate_index) as *Rstate;
    }

    if rstate == null {
        throw("rstate is null");
    }

    return rstate;
}

func set_rstate(rstate: *Rstate) {
    unsafe {
        if windows.TlsSetValue(_tls_rstate_index, rstate as *u8) == 0 {
            throw("bad tls set value");
        }
    }
}

/* -------------------------------------------------------------------------- */

// type Rthread = windows.HANDLE;

// // Note: This function is implemented in assembly because it needs to call to a
// // pointer.  It is technically callconv win64, but since we need call it
// // directly, we don't need to tag it.
// @extern("__berry_win_thread_callback")
// func _win_thread_callback(state: *u8) windows.DWORD;

// func thr_create(fn: func()) Rthread {
//     return windows.CreateThread(
//         null,
//         0,
//         _win_thread_callback._addr,
//         fn._addr,
//         0,
//         null
//     );
// }

func sys_thr_exit(exit_code: int) {
    windows.ExitThread(exit_code as windows.DWORD);
}