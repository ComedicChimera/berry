#require (OS == "windows")

module runtime;

import sys.windows;

func _winError(func_name: string) {
    let buff: [512]u8;
    let i = 0
    for ; i < func_name._len; i++ {
        buff[i] = func_name[i];
    }
    buff[i] = ':';
    buff[i+1] = ' ';

    let buff_offset = i + 2;

    let err = windows.GetLastError();
    let n_written: uint;
    unsafe {
        n_written = windows.FormatMessageA(
            windows.FORMAT_MESSAGE_FROM_SYSTEM,
            null,
            err,
            0,
            buff._ptr + buff_offset,
            buff._len - buff_offset
        ) as uint;
    }

    throw(buff[:buff_offset + n_written] as string);
}

/* ----------------------- Initialization and Exit -------------------------- */

func sysInit() {
    // Get the standard error handle for sys_ewrite.
    _sys_stderr = windows.GetStdHandle(-12 as windows.DWORD);
    if _sys_stderr == windows.INVALID_HANDLE_VALUE {
        _winError("GetStdHandle");
    }

    // Initialize TLS.
    _tls_rtstate_index = windows.TlsAlloc();
    if _tls_rtstate_index == windows.TLS_OUT_OF_INDEXES {
        _winError("TlsAlloc");
    }

    // Setup the exception handler.
    if windows.AddVectoredExceptionHandler(0, _winExcHandler._addr) == null {
        _winError("AddVectoredExceptionHandler");
    }
}

func sysExit(exit_code: int) {
    windows.ExitProcess(exit_code as windows.UINT);
}

/* --------------------------- Printing to Stderr --------------------------- */

let _sys_stderr: windows.HANDLE;

func sysWriteErr(b: []u8) {
    if windows.WriteConsoleA(_sys_stderr, b._ptr, b._len as windows.DWORD, null, null) == 0 {
        _winError("WriteConsoleA");
    }
}

/* --------------------------- Exception Handling --------------------------- */

enum _WinExcCode {
    AccessViolation = windows.EXCEPTION_ACCESS_VIOLATION;
    IntDivideByZero = windows.EXCEPTION_INT_DIVIDE_BY_ZERO;
    StackOverflow = windows.EXCEPTION_STACK_OVERFLOW;
    IntOverflow = windows.EXCEPTION_INT_OVERFLOW;
    FltDenormalOperand = windows.EXCEPTION_FLT_DENORMAL_OPERAND;
    FltDivideByZero = windows.EXCEPTION_FLT_DIVIDE_BY_ZERO;
    FltInexactResult = windows.EXCEPTION_FLT_INEXACT_RESULT;
    FltOverflow = windows.EXCEPTION_FLT_OVERFLOW;
    FltUnderflow = windows.EXCEPTION_FLT_UNDERFLOW;
}

func _winExcHandler(exc_info: *windows.EXCEPTION_POINTERS) windows.DWORD {
    let code = unsafe(exc_info.ExceptionRecord.ExceptionCode as _WinExcCode);

    // Map to the appropriate panic handler.  Some of these handlers are also
    // called directly by code generated by the compiler (ex: divide by zero),
    // but adding in these additional handlers provides redundancy.
    match code {
    case .AccessViolation:
        _panicMem(exc_info.ExceptionRecord._info2 as uint);
    case .IntDivideByZero:
        _panicDivide();
    case .StackOverflow:
        _panicStack();
    case .IntOverflow:
        _panicOverflow();
    case .FltDenormalOperand | .FltDivideByZero | .FltInexactResult | .FltOverflow | .FltUnderflow:
        _panicFloat();
    case _:
        return windows.EXCEPTION_CONTINUE_SEARCH;
    }

    // TODO: should we ever able to continue execution?  If so, we need to
    // increment rip appropriately which will require us to explicitly provide
    // an implementation for CONTEXT in sys.windows. 
    // if (exc_info.ExceptionRecord.ExceptionFlags & windows.EXCEPTION_NONCONTINUABLE) > 0 {
    //     // TODO: fix for multithreading
    //     exit(1);
    // }

    // return windows.EXCEPTION_CONTINUE_EXECUTION;

    // All panic handlers should kill their current thread and thus never
    // return. If we reach here, something is very wrong with the runtime, and
    // we should abort immediately.
    throw("panic handler returned");

    // Unreachable.
    return windows.EXCEPTION_CONTINUE_SEARCH;
}

/* ----------------------- Thread-Local Storage (TLS) ----------------------- */

let _tls_rtstate_index: windows.DWORD = windows.TLS_OUT_OF_INDEXES;

func rtGetState() *RtState {
    let rs = unsafe(windows.TlsGetValue(_tls_rtstate_index) as *RtState);

    if rs == null {
        if windows.GetLastError() == windows.ERROR_SUCCESS {
            throw("runtime state is not initialized");
        } else {
            _winError("TlsGetValue");
        }
    }

    return rs;
}

func _rtSetState(rs: *RtState) {
    unsafe {
        if windows.TlsSetValue(_tls_rtstate_index, rs as *u8) == 0 {
            _winError("TlsSetValue");
        }
    }
}

/* --------------------------------- Threads -------------------------------- */

// type Rthread = windows.HANDLE;

// // Note: This function is implemented in assembly because it needs to call to a
// // pointer.  It is technically callconv win64, but since we don't call it
// // directly, we don't need to tag it.
// @extern("__berry_win_thread_callback")
// func _win_thread_callback(state: *u8) windows.DWORD;

// func thr_create(fn: func()) Rthread {
//     return windows.CreateThread(
//         null,
//         0,
//         _win_thread_callback._addr,
//         fn._addr,
//         0,
//         null
//     );
// }

func sysThrExit(exit_code: int) {
    windows.ExitThread(exit_code as windows.DWORD);
}

/* --------------------------------- Atomics -------------------------------- */

// TODO