#require (OS == "windows")

module runtime;

import sys.windows;

func _winError(func_name: string) {
    let buff: [512]u8;
    let i  = 0;
    for ; i < func_name._len; i++ {
        buff[i] = func_name[i];
    }
    buff[i] = ':' as u8;
    buff[i+1] = ' ' as u8;

    let buff_offset = i + 2;

    let err = windows.GetLastError();
    let n_written: int;
    unsafe {
        n_written = windows.FormatMessageA(
            windows.FORMAT_MESSAGE_FROM_SYSTEM,
            null,
            err,
            0,
            buff._ptr + buff_offset,
            (buff._len - buff_offset) as windows.DWORD,
            null
        ) as int;
    }

    throw(buff[:buff_offset + n_written] as string);
}

/* ----------------------- Initialization and Exit -------------------------- */

func sysInit() {
    // Get necessary system information for runtime.
    _sysGetInfo();

    // Get the standard error handle for sys_ewrite.
    _sys_stderr = windows.GetStdHandle(-12 as windows.DWORD);
    if _sys_stderr == windows.INVALID_HANDLE_VALUE {
        _winError("GetStdHandle");
    }

    // Initialize TLS.
    _tls_rtstate_index = windows.TlsAlloc();
    if _tls_rtstate_index == windows.TLS_OUT_OF_INDEXES {
        _winError("TlsAlloc");
    }

    // Setup the exception handler.
    if windows.AddVectoredExceptionHandler(0, _winExcHandler._addr) == null {
        _winError("AddVectoredExceptionHandler");
    }
}

func sysExit(exit_code: int) {
    windows.ExitProcess(exit_code as windows.UINT);
}

/* --------------------------- Printing to Stderr --------------------------- */

let _sys_stderr: windows.HANDLE;

func sysWriteErr(b: []u8) {
    if windows.WriteConsoleA(_sys_stderr, b._ptr, b._len as windows.DWORD, null, null) == 0 {
        _winError("WriteConsoleA");
    }
}

/* --------------------------- Exception Handling --------------------------- */

enum _WinExcCode {
    AccessViolation = windows.EXCEPTION_ACCESS_VIOLATION;
    IntDivideByZero = windows.EXCEPTION_INT_DIVIDE_BY_ZERO;
    StackOverflow = windows.EXCEPTION_STACK_OVERFLOW;
    IntOverflow = windows.EXCEPTION_INT_OVERFLOW;
    FltDenormalOperand = windows.EXCEPTION_FLT_DENORMAL_OPERAND;
    FltDivideByZero = windows.EXCEPTION_FLT_DIVIDE_BY_ZERO;
    FltInexactResult = windows.EXCEPTION_FLT_INEXACT_RESULT;
    FltOverflow = windows.EXCEPTION_FLT_OVERFLOW;
    FltUnderflow = windows.EXCEPTION_FLT_UNDERFLOW;
}

func _winExcHandler(exc_info: *windows.EXCEPTION_POINTERS) windows.DWORD {
    let code = unsafe(exc_info.ExceptionRecord.ExceptionCode as _WinExcCode);

    // Map to the appropriate panic handler.  Some of these handlers are also
    // called directly by code generated by the compiler (ex: divide by zero),
    // but adding in these additional handlers provides redundancy.
    match code {
    case .AccessViolation:
        _panicMem(exc_info.ExceptionRecord._info2 as uint);
    case .IntDivideByZero:
        _panicDivide();
    case .StackOverflow:
        _panicStack();
    case .IntOverflow:
        _panicOverflow();
    case .FltDenormalOperand | .FltDivideByZero | .FltInexactResult | .FltOverflow | .FltUnderflow:
        _panicFloat();
    case _:
        return windows.EXCEPTION_CONTINUE_SEARCH;
    }

    // TODO: should we ever able to continue execution?  If so, we need to
    // increment rip appropriately which will require us to explicitly provide
    // an implementation for CONTEXT in sys.windows. 
    // if (exc_info.ExceptionRecord.ExceptionFlags & windows.EXCEPTION_NONCONTINUABLE) > 0 {
    //     // TODO: fix for multithreading
    //     exit(1);
    // }

    // return windows.EXCEPTION_CONTINUE_EXECUTION;

    // All panic handlers should kill their current thread and thus never
    // return. If we reach here, something is very wrong with the runtime, and
    // we should abort immediately.
    throw("panic handler returned");

    // Unreachable.
    return windows.EXCEPTION_CONTINUE_SEARCH;
}

/* ----------------------- Thread-Local Storage (TLS) ----------------------- */

let _tls_rtstate_index: windows.DWORD = windows.TLS_OUT_OF_INDEXES;

func rtGetState() *RtState {
    let rs = unsafe(windows.TlsGetValue(_tls_rtstate_index) as *RtState);

    if rs == null {
        if windows.GetLastError() == windows.ERROR_SUCCESS {
            throw("runtime state is not initialized");
        } else {
            _winError("TlsGetValue");
        }
    }

    return rs;
}

func _rtSetState(rs: *RtState) {
    unsafe {
        if windows.TlsSetValue(_tls_rtstate_index, rs as *u8) == 0 {
            _winError("TlsSetValue");
        }
    }
}

/* ----------------------------- Virtual Memory ----------------------------- */

let _sys_page_size: uint = 0;
let _sys_alloc_gran: uint = 0;
let _sys_large_page_align: uint = 0;

func _sysGetInfo() {
    let info: windows.SYSTEM_INFO;
    windows.GetSystemInfo(&info);

    _sys_page_size = info.dwPageSize as uint;
    _sys_alloc_gran = info.dwAllocationGranularity as uint;
    
    // NOT IMPLEMENTED
    _sys_large_page_align = 0;
}

func sysAlignHugePageSize(size: uint) uint {
    if _sys_large_page_align == 0 || size > _sys_large_page_align {
        return mAlignUp(size, _sys_large_page_align);
    } else {
        return mAlignUp(size, _sys_page_size);
    }
}

func sysReserve(size, align: uint) *u8 {
    let data: *u8;

    if align == 0 {
        data = windows.VirtualAlloc(null, size, windows.MEM_RESERVE, windows.PAGE_READWRITE);
    } else {
        size = mAlignUp(size, _sys_page_size);

        let addr_reqs = windows.MEM_ADDRESS_REQUIREMENTS{ null, null, align };
        let param = windows.MEM_EXTENDED_PARAMETER{ 
            windows.MemExtendedParameterAddressRequirements, 
            unsafe(&addr_reqs as uint)
        };

        data = windows.VirtualAlloc2(
            null, null,
            size, windows.MEM_RESERVE, windows.PAGE_READWRITE,
            &param, 1
        );
    }

    if data == null {
        if windows.GetLastError() == windows.ERROR_OUTOFMEMORY {
            return null;
        }

        _winError("VirtualAlloc");
    }

    return data;
}

func sysCommit(addr: *u8, size, align: uint) *u8 {
    let data: *u8;

    if addr != null {
        data = windows.VirtualAlloc(addr, size, windows.MEM_COMMIT, windows.PAGE_READWRITE);
    } elif align > 0 {
        size = mAlignUp(size, _sys_page_size);

        let addr_reqs = windows.MEM_ADDRESS_REQUIREMENTS{ null, null, align };
        let param = windows.MEM_EXTENDED_PARAMETER{ 
            windows.MemExtendedParameterAddressRequirements, 
            unsafe(&addr_reqs as uint)
        };

        data = windows.VirtualAlloc2(
            null, null,
            size, windows.MEM_COMMIT, windows.PAGE_READWRITE,
            &param, 1
        );
    } else {
        data = windows.VirtualAlloc(null, size, windows.MEM_COMMIT, windows.PAGE_READWRITE);
    }

    if data == null {
        if windows.GetLastError() == windows.ERROR_OUTOFMEMORY {
            return null;
        }

        _winError("VirtualAlloc");
    }

    return data;
}

func sysReset(addr: *u8, size: uint) {
    if windows.VirtualAlloc(addr, size, windows.MEM_RESET, windows.PAGE_NOACCESS) == null {
        _winError("VirtualAlloc");
    }
}

func sysUnreset(addr: *u8, size: uint) {
    if windows.VirtualAlloc(addr, size, windows.MEM_RESET_UNDO, windows.PAGE_READWRITE) == null {
        _winError("VirtualAlloc");
    }   
}

func sysRelease(addr: *u8, size: uint) {
    if windows.VirtualFree(addr, size, windows.MEM_RELEASE) == 0 {
        _winError("VirtualFree");
    }
}

/* --------------------------------- Threads -------------------------------- */

@inline
func sysGetThrID() uint {
    return windows.GetCurrentThreadId() as uint;
}

// type Rthread = windows.HANDLE;

// // Note: This function is implemented in assembly because it needs to call to a
// // pointer.  It is technically callconv win64, but since we don't call it
// // directly, we don't need to tag it.
// @extern("__berry_win_thread_callback")
// func _win_thread_callback(state: *u8) windows.DWORD;

// func thr_create(fn: func()) Rthread {
//     return windows.CreateThread(
//         null,
//         0,
//         _win_thread_callback._addr,
//         fn._addr,
//         0,
//         null
//     );
// }

func thrYield() {
    windows.SwitchToThread();
}

func sysThrExit(exit_code: int) {
    windows.ExitThread(exit_code as windows.DWORD);
}