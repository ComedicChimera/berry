#require (OS == "windows")

module runtime;

import sys.windows;

func sysInit() {
    // Get the standard error handle for sys_ewrite.
    _sys_stderr = windows.GetStdHandle(-12 as windows.DWORD);

    // Initialize TLS.
    _tls_rstate_index = windows.TlsAlloc();
    if _tls_rstate_index == windows.TLS_OUT_OF_INDEXES {
        throw("bad tls alloc");
    }

    // Setup the exception handler.
    windows.AddVectoredExceptionHandler(0, _winExcHandler._addr);
}

func sysExit(exit_code: int) {
    windows.ExitProcess(exit_code as windows.UINT);
}

/* -------------------------------------------------------------------------- */

let _sys_stderr: windows.HANDLE;

func sysWriteErr(b: []u8) {
    windows.WriteConsoleA(_sys_stderr, b._ptr, b._len as windows.DWORD, null, null);
}

/* -------------------------------------------------------------------------- */

enum _WinExcCode {
    AccessViolation = windows.EXCEPTION_ACCESS_VIOLATION;
    IntDivideByZero = windows.EXCEPTION_INT_DIVIDE_BY_ZERO;
    StackOverflow = windows.EXCEPTION_STACK_OVERFLOW;
    IntOverflow = windows.EXCEPTION_INT_OVERFLOW;
    FltDenormalOperand = windows.EXCEPTION_FLT_DENORMAL_OPERAND;
    FltDivideByZero = windows.EXCEPTION_FLT_DIVIDE_BY_ZERO;
    FltInexactResult = windows.EXCEPTION_FLT_INEXACT_RESULT;
    FltOverflow = windows.EXCEPTION_FLT_OVERFLOW;
    FltUnderflow = windows.EXCEPTION_FLT_UNDERFLOW;
}

func _winExcHandler(exc_info: *windows.EXCEPTION_POINTERS) windows.DWORD {
    let code: _WinExcCode;
    unsafe {
        code = exc_info.ExceptionRecord.ExceptionCode as _WinExcCode;
    }

    // Map to the appropriate panic handler.  Some of these handlers are also
    // called directly by code generated by the compiler (ex: divide by zero),
    // but adding in these additional handlers provides redundancy.
    match code {
    case .AccessViolation:
        _panicMem(exc_info.ExceptionRecord._info2 as uint);
    case .IntDivideByZero:
        _panicDivide();
    case .StackOverflow:
        _panicStack();
    case .IntOverflow:
        _panicOverflow();
    case .FltDenormalOperand | .FltDivideByZero | .FltInexactResult | .FltOverflow | .FltUnderflow:
        _panicFloat();
    case _:
        return windows.EXCEPTION_CONTINUE_SEARCH;
    }

    // TODO: should we ever able to continue execution?  If so, we need to
    // increment rip appropriately which will require us to explicitly provide
    // an implementation for CONTEXT in sys.windows. 
    // if (exc_info.ExceptionRecord.ExceptionFlags & windows.EXCEPTION_NONCONTINUABLE) > 0 {
    //     // TODO: fix for multithreading
    //     exit(1);
    // }

    // return windows.EXCEPTION_CONTINUE_EXECUTION;

    // All panic handlers should kill their current thread and thus never
    // return. If we reach here, something is very wrong with the runtime, and
    // we should abort immediately.
    throw("panic handler returned");

    // Unreachable.
    return windows.EXCEPTION_CONTINUE_SEARCH;
}

/* -------------------------------------------------------------------------- */

let _tls_rstate_index: windows.DWORD = windows.TLS_OUT_OF_INDEXES;

func rtGetState() *Rstate {
    let rstate: *Rstate;

    unsafe {
        rstate = windows.TlsGetValue(_tls_rstate_index) as *Rstate;
    }

    if rstate == null {
        throw("rstate is null");
    }

    return rstate;
}

func rtSetState(rstate: *Rstate) {
    unsafe {
        if windows.TlsSetValue(_tls_rstate_index, rstate as *u8) == 0 {
            throw("bad tls set value");
        }
    }
}

/* -------------------------------------------------------------------------- */

// type Rthread = windows.HANDLE;

// // Note: This function is implemented in assembly because it needs to call to a
// // pointer.  It is technically callconv win64, but since we don't call it
// // directly, we don't need to tag it.
// @extern("__berry_win_thread_callback")
// func _win_thread_callback(state: *u8) windows.DWORD;

// func thr_create(fn: func()) Rthread {
//     return windows.CreateThread(
//         null,
//         0,
//         _win_thread_callback._addr,
//         fn._addr,
//         0,
//         null
//     );
// }

func sysThrExit(exit_code: int) {
    windows.ExitThread(exit_code as windows.DWORD);
}