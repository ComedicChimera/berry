module runtime;

// NOTE: The panic functions not tagged @abientry are directly called by the
// signal handler implemented in the appropriate os_*.bry source file.

func _panic_stack() {
    rputs("panic: stack overflow\n\n");

    _dopanic();
}

func _panic_mem(addr: uint) {
    if addr == 0 {
        rputs("panic: null pointer dereference\n\n");
    } else {
        // TODO: print address
        rputs("panic: invalid memory access\n\n");
    }

    _dopanic();
}

func _panic_float() {
    rputs("panic: floating point error");

    _dopanic();
}

@abientry("__berry_panic_overflow")
func _panic_overflow() {
    rputs("panic: integer overflow\n\n");

    _dopanic();
}

@abientry("__berry_panic_divide")
func _panic_divide() {
    rputs("panic: integer divide by zero\n\n");

    _dopanic();
}

@abientry("__berry_panic_shift")
func _panic_shift() {
    rputs("panic: shift overflow\n\n");

    _dopanic();
}

@abientry("__berry_panic_oob")
func _panic_oob() {
    rputs("panic: index out of bounds\n\n");

    _dopanic();
}

@abientry("__berry_panic_badslice")
func _panic_badslice() {
    rputs("panic: bad slice range\n\n");

    _dopanic();
}

@abientry("__berry_panic_unreachable")
func _panic_unreachable() {
    rputs("panic: unreachable\n\n");

    _dopanic();
}

@abientry("__berry_panic_user")
func _panic_user(message: string) {
    rputs("panic: ");
    rputs(message);
    rputs("\n\n");

    _dopanic();
}

/* -------------------------------------------------------------------------- */

func _dopanic() {
    let rstate = get_rstate();

    if rstate.panic_depth > 0 {
        throw("panic in runtime");
    }

    rstate.panic_depth++;

    // TODO: stack tracing

    // thr_exit(1);
    exit(1);
}

/* -------------------------------------------------------------------------- */

func throw(message: string) {
    rputs("throw: ");
    rputs(message);
    rputs("\n\n");

    abort();
}

func abort() {
    sys_exit(1);
}