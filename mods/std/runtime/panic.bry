module runtime;

// NOTE: The panic functions not tagged @abientry are directly called by the
// signal handler implemented in the appropriate os_*.bry source file.

func _panic_stack() {
    rputs("panic: stack overflow\n\n");

    _dopanic();
}

func _panic_overflow() {
    rputs("panic: integer overflow\n\n");

    _dopanic();
}

func _panic_divide() {
    rputs("panic: integer divide by zero\n\n");

    _dopanic();
}

func _panic_mem(addr: uint) {
    if addr == 0 {
        rputs("panic: null pointer dereference\n\n");
    } else {
        // TODO: print address
        rputs("panic: invalid memory access\n\n");
    }

    _dopanic();
}

func _panic_float() {
    rputs("panic: floating point error");

    _dopanic();
}

@abientry("__berry_panic_oob")
func _panic_oob() {
    rputs("panic: index out of bounds\n\n");

    _dopanic();
}

@abientry("__berry_panic_badslice")
func _panic_badslice() {
    rputs("panic: bad slice range\n\n");

    _dopanic();
}

@abientry("__berry_panic_unreachable")
func _panic_unreachable() {
    rputs("panic: unreachable\n\n");

    _dopanic();
}

@abientry("__berry_panic_user")
func _panic_user(message: string) {
    rputs("panic: ");
    rputs(message);
    rputs("\n\n");

    _dopanic();
}

enum PanicMode {
    Normal;
    Throw;
    Abort;
}

let panic_mode: PanicMode = .Normal;

func _dopanic() {
    match panic_mode {
    case .Normal:
        panic_mode = .Throw;
    case .Throw:
        throw("panic inside runtime");
    case _:
        // This is PanicMode.Abort or an invalid panic mode.  In either case,
        // the runtime state is badly corrupted, and we want to crash and burn.
        abort();
    }

    // TODO: stack tracing

    exit(1);
}

/* -------------------------------------------------------------------------- */

func throw(message: string) {
    panic_mode = .Abort;

    rputs("throw: ");
    rputs(message);
    rputs("\n\n");

    exit(-1);
}

func abort() {
    sys_exit(-1);
}